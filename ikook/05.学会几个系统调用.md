### 进程管理

创建进程的系统调用叫作 **`fork`**。

在 Linux 中，要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作**父进程**（Parent Process），新的进程叫作**子进程**(Child Process)。

在创建新的进程时，fork 系统调用会将各个 Linux 子系统为父进程创建的数据结构玩转的拷贝一份给子进程。但是这样子进程和父进程就一样了，也就失去了意义，那么怎样区分开来呢？

对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。这样首先在返回值这里就有了一个区分，然后通过 if-else 判断，如果是父进程，还接着做原来的事情；如果是子进程，需要请求另一个系统调用 **`execve`** 来执行另一个程序，这个时候，子进程和父进程就会彻底区分开来，也就产生了一个分支(fork)。

![](https://static001.geekbang.org/resource/image/e8/7f/e8ee83d78538bd43d3835662ded92e7f.jpeg)

可见，Linux 创建进程的策略为“先拷贝，再修改”。那么新的进程都是父进程 fork 出来的，那到底谁是第一个进程呢？

当操作系统启动的时候，会先创建一个所有用户进程的“祖宗进程”。这个“祖宗进程”就是第一个进程。

有些时候，父进程需要关注子进程的运行情况，则需要 **`waitpid`** 系统调用，父进程可以调用他，将子进程的进程号作为参数传给它，这样父进程就可以知道子进程进行完了没有，成功与否。

### 内存管理

在操作系统中，每个进程都有自己的内存空间，互相之间不干扰，有独立的**进程内存空间**。

对于进程的内存空间来讲，放程序代码的这部分，称为**代码段(Code Segment)**。

对于进程的内存空间来讲，放进程运行中产生数据的这部分，称为**数据段(Date Segment)**，其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；也要动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（heap）

一个进程的内存空间很大，32 为的是 4G，64 为的就更大了，不可能有那么多物理内存。所以，进程自己不用的部分就不用管，只有进程要去使用部分内存的时候，才会使用内存管理的系统调用来登记，说自己马上就要使用了，希望分配一部分内存，但是这不代表真的就对应到了物理内存。只有真正写入数据的时候，发现没有对应物理内存，才会触发一个中断，现分配物理内存。

![](https://static001.geekbang.org/resource/image/e9/0b/e9bcfb17a7ac8c21bcc6b0828641850b.jpeg)

介绍两个在堆里面分配内存的系统调用：**brk** 和 **mmap**。

当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起。当分配内存数量比较大的时候，使用 mmap，会重新划分一块区域。

### 文件管理

文件为了持久化保存，需要放在文件系统里面；文件之所以能够做到这一点，一方面是因为**介质**，另一方面是因为**格式**。

文件管理做的无非就是创建、打开、读、写等。

对于文件的操作，下面的六个系统调用是最重要的:

- 对于已经有的文件，可以使用 `open` 打开文件，`close` 关闭这个文件；
- 对于没有的文件，可以使用 `create` 创建文件;
- 打开文件以后，可以使用 `lseek` 跳转到文件的某个位置；
- 可以对文件的内容进行读写，读的系统调用是 `read`，写是 `write`。

Linux 中，一切皆文件：

- 启用一个进程，需要一个程序文件，这是一个二进制文件。
- 启用的时候，要加载一些配置文件，这是文本文件。
- 控制台日志打印，也是一个文件，是标准输出 stdout 文件。
- 这个进程的输出可以作为另一个进程的输入，这种方式成为管道，管道也是一个文件。
- 进程可以通过网络和其他进程进行通信，建立的 Socket 也是一个文件。
- 进程需要访问外部设备，设备也是一个文件，
- 文件都被存储在文件夹里面，文件夹也是一个文件。
- 进程运行起来，要想看到进程运行的情况，会在 /proc 下面有对应的进程号，还是一系列文件。

![](https://static001.geekbang.org/resource/image/e4/df/e49b5c2a78ac09903d697126bfe6c5df.jpeg)

每个文件，Linux 都会分配一个文件描述符(File Descriptor)，这是一个整数。有了这个文件描述符，就可以使用系统调用，查看或者干预进程的方方面面。

### 信号处理

软件运行过程中会遇到各种情况，当遇到情况的时候就需要**信号(Signal)**来处理。经常遇到的信号有这几种：
- 在一个程序执行的时候，在键盘输入“Ctrl+C”，这就是中断信号，正在执行的命令就会中止退出；
- 非法访问内存；
- 硬件故障；
- 用户进程通过 kill 函数，将一个用户信号发送给另一个进程。

对于一些不严重的信号，可以忽略，但是像 SIGKILL(用户终止一个进程的信号)和 SIGSTOP（用户中止一个进程的信号）是不能忽略的，可以执行对于该信号的默认动作。每种信号都定义了默认的动作。也可以提供信号处理函数，可以通过 sigaction 系统调用，注册一个信号处理函数。

### 进程间通信

进程之间通信有两种基本的方式**消息队列(Message Queue)**和**共享内存**。

消息队列：其实就是发个消息，不需要一段很长的数据。这个消息队列是在内核里的，可以通过 **`msgget`** 创建一个新的队列，**`msgsnd`** 将消息发送到消息队列，而消息接收方可以使用 **`msgrcv`** 从消息队列中取出消息。

当进程间需要交互的信息量比较大的时候，就需要使用 共享内存 的方式，也就是两个进程共享一块内存空间。可以通过 **`shmget`** 创建一个共享内存块，通过 **`shmar`** 将共享内存映射到自己的内存空间，然后就可以读写了。

但是共享一个内存空间，就会存在竞争的问题，如果大家同时修改同一块数据怎么办？这就需要一种方式，让不同的人能够排他的访问，这就是信号量的机制 **`Semaphore`**。

这个机制很复杂，说一种简单的场景。

对于只允许一个人访问的需求，可以将信号量设置为 1。当一个人需要访问的时候，先调用 sem_wait。如果这时候没人访问，则占用这个信号量，他就可以开始访问了。如果这时候另一个人需要访问，也会调用 sem_wait。由于有一个人已经在访问了，所以后面的人就必须等待上一个人访问完成。当上一个人访问完成之后，会调用 sem_post 将信号量释放，于是下一个人就等待结束，可以访问资源了。

### 网络通信

不同的机器通过网络相互通信，要遵循相同的网络协议，也就是 TCP/IP 网络协议栈。Linux 内核里面有对于网络协议栈的实现。那如何暴露出来使用呢？

网络服务是通过 Socket 来提供服务的。所以，在通信之前，双方都要建立一个 Socket。

可以通过 Socket 系统调用建立一个 Socket。Socket 也是一个文件，也有一个文件描述符，也可以通过读写函数进行通信。

### 总结

![](https://static001.geekbang.org/resource/image/ff/f0/ffb6847b94cb0fd086095ac263ac4ff0.jpg)