# 05-学会几个系统调用：咱们公司能接哪些类型的项目？-学习总结

## 进程管理

（1）创建进程：fork

fork 中文为「分支」的意思，创建进程需要一个老的进程调用 fork 来实现，大概就是把父进程直接复制为子进程。这时如果不做处理，那么子进程会按照父进程一样的程序代码执行下去，所以需要做如下处理：通过 fork 调用的返回值判断是否是子进程，如果是子进程，就通过另一个系统调用 execve 来执行另一个程序，这是子进程相当于是一个分支。

所以，操作系统启动时先创建一个所有用户进程的「祖宗进程」。

（2）运行二进制文件：execve

（3）等待子进程结束：waitpid

父进程可以调用 waitpid 来知道子进程运行结果。

## 内存管理

每个进程都有独立的**进程内存空间**，其中放程序代码的部分叫**代码段**，放进程运行中产生数据的部分叫**数据段**，数据段中的局部变量会在进入另一个函数时释放，还有一些需要指明才销毁的变量称为**堆**。

两个在堆里面分配内存的系统调用：

- brk：用来调整内存数据段，比如扩大原来的数据段。

- mmap：重新划分一块内存，做内存映射。

## 文件管理

对文件的操作有 6 个重要的系统调用：

- open
- close
- create
- lseek：定位，即跳到文件某个位置
- read
- write

Linux 有个特点是：**一切皆文件**。每个文件，Linux 都会分配一个文件描述符（一个整数），有了它就可以通过系统调用查看或干预进程的方方面面。

## 信号处理

在进程运行中发生异常时，会发送一个**信号**给进程，对于一些不严重的信号，进程可以选择忽略，对于不能忽略的信号，可以执行对于该信号的默认动作，也可以提供信号处理函数。可以通过 sigaction 系统调用，注册一个信号处理函数。

## 进程间通信

进程间通信的方式有：

（1）消息队列，通信的数据较少

- msgget：创建一个新的队列
- msgsnd：将消息发送到消息队列
- msgrcv：从队列中取消息

（2）内存共享，通信的数据较大

- shmget：创建一个共享内存块
- shmat：将共享内存映射到自己的内存空间

为了防止两个进程同时修改同一块内存数据，就有了信号量机制 Semaphore，如果一个进程占用了信号量，其他进程就只能等待，有 2 个相关的系统调用是：

- sem_wait：抢占信号量
- sem_post：释放信号量

## 网络通信

Linux 内核里有对于 TCP/IP 网络协议栈的实现，网络服务通过套接字 Socket 来提供服务。两个机器在通信之前，双方都要建立一个 Socket。可以通过 Socket 系统调用建立一个 Socket，Socket 也是一个文件，也可以通过读写函数进行通信。和 Socket 相关的系统调用有：

- socket：创建套接字
- bind：绑定端口
- connect：发起连接
- accept：接收连接
- listen：监听

## Glibc

Glibc 是 Linux 下使用的开源的标准 C 库，它提供了丰富的 API，其中封装了系统调用。

## 课堂练习

有个命令 strace，常用来跟踪进程执行时系统调用和所接收的信号。

用 strace 跟踪`ls -al`的系统调用，大体流程如下：
1. 先执行 execve，调用ls命令;
2. 调用 open、read、fstat、mmap、mprotect、mmap、close 读取动态链库和系统配置文件；
3. 读取 passwd、group 文件，获取用户信息，lstat、lgetxattr、getxattr 获取文件属性，同时判断权限；
4. 调用 write 输出内容；
5. munmap 释放内存，close 关闭。