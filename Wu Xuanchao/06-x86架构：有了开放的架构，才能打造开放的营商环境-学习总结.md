# 06-x86架构：有了开放的架构，才能打造开放的营商环境-学习总结

x86 架构是一个开放的硬件平台。

## 计算机的工作模式是什么样的？

计算机的核心是 CPU，CPU 在计算时自己无法保存中间结果，所以需要依靠内存来保存。CPU 与内存等其他设备是由总线（Bus）来连接的。

CPU 分为三部分：

- 运算单元（用来做加法、位移等运算）
- 数据单元（包括 CPU 内部的缓存和数据寄存器组，暂时存放从内存拿来的数据和运算结果，这样运算单元就不用每次计算都要到内存拿数据）
- 控制单元（获得指令并执行指令，指挥运算单元如何操作数据单元）

CPU 和内存是如何配合工作的？

1. 内存中保存着多个进程的数据，每个进程的数据分为代码段和数据段。CPU 中的**指令起始地址寄存器**和**数据起始地址寄存器**保存着当前处理进程的代码段起始地址和数据段起始地址，这样在**进程切换**时就能知道当前的计算任务是哪个进程的。
2. CPU 控制单元中的**指令指针寄存器**存放着下一条指令在内存代码段中的地址，控制单元根据指令地址拿出指令，放入控制单元的**指令寄存器**。
3. 当前指令的一部分交给了运算单元，另一部分交给数据单元，数据单元根据数据地址从内存数据段把数据读到**数据寄存器**，运算单元做完运算，产生的结果也暂存在数据寄存器。最终，会有指令将数据写回内存数据段。

可以看出，CPU 和内存间传送的数据有两种：地址数据和真正的数据，所以 CPU 和内存之间的总线也分为**地址总线**和**数据总线**。地址总线的位数决定了能访问的地址范围，数据总线的位数决定了一次能拿多大的数据。

## x86 成为开放平台历史中的重要一笔

当年 IBM 做的 PC 使用了英特尔的 8086 芯片作为CPU，因此有了 x86 架构。x86 架构成为了行业的开放事实标准，英特尔后来的 CPU 也要遵循标准、开放和兼容。

## 从 8086 的原理说起

8086 处理器内部有 8 个 16 位的通用寄存器，也就是 CPU 的数据单元。

控制单元的寄存器有：

- IP 寄存器（指令指针寄存器，指向代码段中下一条指令的位置，CPU 通过它把指令加载到指令队列，然后交给运算单元去执行）
- CS（代码段寄存器，存放代码段的起始位置，代码段的偏移量放在 IP 寄存器中）
- DS（数据段寄存器，存放数据段的起始位置，数据段的偏移量放在通用寄存器中）
- SS（栈寄存器，秉承数据后进先出的原则，程序的函数调用信息会在栈寄存器中 push 或 pop）
- ES

除了 IP 寄存器，其他四个是**段寄存器**。8086 的地址总线地址是 20 位的，而 CS、DS、IP 寄存器和通用寄存器都是 16 位的，为了凑够 20 位，就把 CS 和 DS 中的值左移 4 位，也就是乘以 16，再加上 16 位的偏移量，最终得到 20 位的数据地址，也就是 8086 能区分出的地址大小是 2^20=1M，而一个段最大大小是 2^16=64k。

## 再来说 32 位处理器

为了在开放架构的基础上保持兼容，32 位处理器相比 8086 处理器做的改动：

- 将 8 个 16 位的通用寄存器扩展到 32 位，这样就兼容了 16 位和 8 位；
- IP 寄存器扩展为 32 位，兼容 16 位；
- 因为原先的段寄存器是 20 位的，不好兼容，所以换个思路，段寄存器仍是16位，段寄存器不再保存段的起始地址，起始地址放在内存中的一个表格上，表格用**段描述符**来组织，寄存器里保存的是在这个表格中的哪一项，称为**选择子**。这样，拿段起始地址就要先经过这个表格，为了快速拿到段起始地址，段寄存器会从内存中拿到 CPU 的描述符高速缓冲器中。在 32 位系统架构下，前一种模式称为**实模式**，后一种模式称为**保护模式**。当系统刚启动时是处于实模式的，后面可以切换为保护模式，这样可以获得更多的内存。

## 课堂练习

汇编语言中一些简单命令的作用：

move a b :把b值赋给a,使a=b
call和ret :call调用子程序，子程序以ret结尾
jmp :无条件跳
int :中断指令
add a b : 加法,a=a+b
or :或运算
xor :异或运算
shl :算术左移
ahr :算术右移
push xxx :压xxx入栈
pop xxx: xxx出栈
inc: 加1
dec: 减1
sub a b : a=a-b
cmp: 减法比较，修改标志位

